import type { Agent2Output } from "./types";

export interface Agent3Output {
  database_migrations: string[];
  api_routes: Array<{
    path: string;
    method: string;
    code: string;
  }>;
  database_queries: Array<{
    name: string;
    query: string;
  }>;
  middleware: Array<{
    name: string;
    code: string;
  }>;
  authentication_setup: {
    provider: string;
    config: Record<string, unknown>;
  };
}

/**
 * Agent 3: Database & Backend Developer
 * 
 * Responsibilities:
 * - Create SQL migrations based on database schema
 * - Generate API routes for all endpoints
 * - Write database queries and helpers
 * - Set up authentication
 * - Create middleware for security and validation
 */
export async function executeAgent3(agent2Output: Agent2Output): Promise<Agent3Output> {
  const startTime = Date.now();

  try {
    // Generate database migrations
    const migrations = generateDatabaseMigrations(agent2Output.database_schema);

    // Generate API routes
    const apiRoutes = generateAPIRoutes(agent2Output.api_endpoints, agent2Output.database_schema);

    // Generate database queries
    const queries = generateDatabaseQueries(agent2Output.database_schema);

    // Generate middleware
    const middleware = generateMiddleware(agent2Output);

    // Set up authentication
    const authSetup = setupAuthentication(agent2Output);

    const executionTime = Date.now() - startTime;
    console.log(`Agent 3 completed in ${executionTime}ms`);

    return {
      database_migrations: migrations,
      api_routes: apiRoutes,
      database_queries: queries,
      middleware,
      authentication_setup: authSetup,
    };
  } catch (error) {
    console.error("Agent 3 error:", error);
    throw new Error(`Agent 3 failed: ${error instanceof Error ? error.message : String(error)}`);
  }
}

function generateDatabaseMigrations(schema: Agent2Output["database_schema"]): string[] {
  const migrations: string[] = [];

  if (!schema.tables || schema.tables.length === 0) {
    return migrations;
  }

  // Generate initial schema migration
  let migrationSQL = `-- Initial database schema migration
-- Generated by Agent 3: Database & Backend Developer

`;

  schema.tables.forEach((table) => {
    migrationSQL += `-- Create ${table.name} table
CREATE TABLE IF NOT EXISTS ${table.name} (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
`;

    table.columns.forEach((column, index) => {
      if (column === "id") return; // Skip id as it's already defined

      let columnDef = `  ${column}`;

      // Infer column type based on name
      if (column.includes("email")) {
        columnDef += " VARCHAR(255) UNIQUE NOT NULL";
      } else if (column.includes("password")) {
        columnDef += " TEXT NOT NULL";
      } else if (column.includes("price") || column.includes("amount")) {
        columnDef += " DECIMAL(10, 2) NOT NULL DEFAULT 0";
      } else if (column.includes("count") || column.includes("stock") || column.includes("quantity")) {
        columnDef += " INTEGER NOT NULL DEFAULT 0";
      } else if (column.includes("is_") || column.includes("has_")) {
        columnDef += " BOOLEAN DEFAULT false";
      } else if (column.includes("_at")) {
        columnDef += " TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP";
      } else if (column.includes("_id")) {
        columnDef += " UUID REFERENCES " + column.replace("_id", "") + "s(id) ON DELETE CASCADE";
      } else if (column.includes("url") || column.includes("link")) {
        columnDef += " TEXT";
      } else if (column.includes("description") || column.includes("content")) {
        columnDef += " TEXT";
      } else {
        columnDef += " TEXT NOT NULL";
      }

      migrationSQL += columnDef;
      if (index < table.columns.length - 2) {
        migrationSQL += ",\n";
      } else {
        migrationSQL += "\n";
      }
    });

    migrationSQL += `);\n\n`;

    // Add indexes
    migrationSQL += `-- Indexes for ${table.name}\n`;
    table.columns.forEach((column) => {
      if (column.includes("_id") || column === "email" || column.includes("_at")) {
        migrationSQL += `CREATE INDEX IF NOT EXISTS idx_${table.name}_${column} ON ${table.name}(${column});\n`;
      }
    });

    migrationSQL += `\n`;
  });

  // Add RLS policies
  migrationSQL += `-- Enable Row Level Security\n`;
  schema.tables.forEach((table) => {
    migrationSQL += `ALTER TABLE ${table.name} ENABLE ROW LEVEL SECURITY;\n`;
  });

  migrationSQL += `\n-- RLS Policies\n`;
  schema.tables.forEach((table) => {
    if (table.columns.includes("user_id")) {
      migrationSQL += `
CREATE POLICY "Users can view their own ${table.name}"
  ON ${table.name}
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own ${table.name}"
  ON ${table.name}
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own ${table.name}"
  ON ${table.name}
  FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own ${table.name}"
  ON ${table.name}
  FOR DELETE
  USING (auth.uid() = user_id);

`;
    }
  });

  migrations.push(migrationSQL);
  return migrations;
}

function generateAPIRoutes(
  endpoints: Agent2Output["api_endpoints"],
  schema: Agent2Output["database_schema"]
): Array<{ path: string; method: string; code: string }> {
  const routes: Array<{ path: string; method: string; code: string }> = [];

  endpoints.forEach((endpoint) => {
    const [method, path] = endpoint.split(" ");
    const pathParts = path.split("/").filter(Boolean);
    const resource = pathParts[pathParts.length - 1];

    // Find corresponding table
    const table = schema.tables.find((t) => 
      t.name === resource || 
      t.name === resource + "s" || 
      t.name === resource.slice(0, -1)
    );

    if (!table) {
      console.warn(`No table found for endpoint: ${endpoint}`);
      return;
    }

    let code = "";

    if (method === "GET") {
      code = `import { NextResponse } from "next/server";
import { createClient } from "@/lib/database";

export async function GET(request: Request) {
  try {
    const supabase = createClient();
    
    const { data, error } = await supabase
      .from("${table.name}")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}`;
    } else if (method === "POST") {
      code = `import { NextResponse } from "next/server";
import { createClient } from "@/lib/database";

export async function POST(request: Request) {
  try {
    const supabase = createClient();
    const body = await request.json();

    const { data, error } = await supabase
      .from("${table.name}")
      .insert(body)
      .select()
      .single();

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(data, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}`;
    } else if (method === "PUT" || method === "PATCH") {
      code = `import { NextResponse } from "next/server";
import { createClient } from "@/lib/database";

export async function ${method}(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const supabase = createClient();
    const body = await request.json();

    const { data, error } = await supabase
      .from("${table.name}")
      .update(body)
      .eq("id", params.id)
      .select()
      .single();

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}`;
    } else if (method === "DELETE") {
      code = `import { NextResponse } from "next/server";
import { createClient } from "@/lib/database";

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const supabase = createClient();

    const { error } = await supabase
      .from("${table.name}")
      .delete()
      .eq("id", params.id);

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}`;
    }

    routes.push({
      path,
      method,
      code,
    });
  });

  return routes;
}

function generateDatabaseQueries(schema: Agent2Output["database_schema"]): Array<{ name: string; query: string }> {
  const queries: Array<{ name: string; query: string }> = [];

  schema.tables.forEach((table) => {
    // Get all query
    queries.push({
      name: `getAll${capitalize(table.name)}`,
      query: `SELECT * FROM ${table.name} ORDER BY created_at DESC`,
    });

    // Get by ID query
    queries.push({
      name: `get${capitalize(table.name.slice(0, -1))}ById`,
      query: `SELECT * FROM ${table.name} WHERE id = $1`,
    });

    // Get by user_id query if applicable
    if (table.columns.includes("user_id")) {
      queries.push({
        name: `get${capitalize(table.name)}ByUserId`,
        query: `SELECT * FROM ${table.name} WHERE user_id = $1 ORDER BY created_at DESC`,
      });
    }
  });

  return queries;
}

function generateMiddleware(agent2Output: Agent2Output): Array<{ name: string; code: string }> {
  const middleware: Array<{ name: string; code: string }> = [];

  // Auth middleware
  middleware.push({
    name: "auth",
    code: `import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { createClient } from "@/lib/database";

export async function authMiddleware(request: NextRequest) {
  const supabase = createClient();
  
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    return NextResponse.json(
      { error: "Unauthorized" },
      { status: 401 }
    );
  }

  return null;
}`,
  });

  // CORS middleware
  middleware.push({
    name: "cors",
    code: `import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function corsMiddleware(request: NextRequest) {
  const response = NextResponse.next();
  
  response.headers.set("Access-Control-Allow-Origin", "*");
  response.headers.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  response.headers.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  return response;
}`,
  });

  // Rate limiting middleware
  middleware.push({
    name: "rateLimit",
    code: `import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

const rateLimitMap = new Map<string, { count: number; resetTime: number }>();

export function rateLimitMiddleware(request: NextRequest, limit = 100) {
  const ip = request.ip || "unknown";
  const now = Date.now();
  const windowMs = 60 * 1000; // 1 minute

  const record = rateLimitMap.get(ip);

  if (!record || now > record.resetTime) {
    rateLimitMap.set(ip, { count: 1, resetTime: now + windowMs });
    return null;
  }

  if (record.count >= limit) {
    return NextResponse.json(
      { error: "Too many requests" },
      { status: 429 }
    );
  }

  record.count++;
  return null;
}`,
  });

  return middleware;
}

function setupAuthentication(agent2Output: Agent2Output): {
  provider: string;
  config: Record<string, unknown>;
} {
  return {
    provider: "supabase",
    config: {
      url: process.env.NEXT_PUBLIC_SUPABASE_URL,
      anonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      enableEmailAuth: true,
      enableOAuth: true,
      oauthProviders: ["google", "github"],
    },
  };
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
